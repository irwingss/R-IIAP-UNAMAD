---
title: "Modelamiento Avanzado: GLM Hurdle y GLMM"
Subtitle: "Ciencia de Datos en R aplicada a la Conservación de Fauna Silvestre"
Author: "Blgo. Irwing S. Saldaña"
output: html_document
editor_options:
  chunk_output_type: console
---

Instalar librerías nuevas

```{r eval=FALSE}
install.packages("mcemGLM")
install.packages("pscl")
install.packages("GLMMadaptive")
install.packages("lmtest")

```

Librarías para activar

```{r}
library(tidyverse)
library(ggpubr)
library(mcemGLM)
library(pscl)
library(GLMMadaptive)
library(MASS)
library(sjPlot)
library(lmtest)
library(lme4)
```

#**5. Modelos Hurdle**

## 5.1. Problema aplicativo:

Se tiene una base de datos de pesca en una zona de actividad turística dentro de un Parque Nacional. El estudio busca identificar qué características de las visitas impactan en la cantidad de pesces (conteo) pezcados por los visitantes
 - Conteo: >0 --- Pesca
 - Conteo: =0 --- No Pesca

Variables:
 - livebait: usa presa viva para pezcar (Binaria)
 - camper: vineron con una carabana (Binaria)
 - persons: cantidad de personas del grupo
 - child: cantidad de niños del grupo
 - xb: densidad de Carpas
 - zg: densidad de Pez Gatos
 - count: cantidad de peces pescados por el grupo (Y)

```{r}
# Carga la base de datos pesca
pesca <- openxlsx::read.xlsx("slide4/bases/pesca.xlsx")
pesca <- openxlsx::read.xlsx(file.choose())
str(pesca)
View(pesca)

# Convertir a factor las variables livebait y camper
pesca <- pesca %>% 
  mutate_at(.vars=vars(livebait, camper),
            .funs=list(factor))

pesca$nofish <- NULL

# Revisión del exceso de ceros en la base de datos
plot(table(pesca$count))

# El Primer paso siempre hacer un GLM de Poisson
# y revisar sobredispersión e inflación de ceros
pois.prev <- glm(count ~ ., data = pesca, family="poisson")
check_overdispersion(pois.prev)
check_collinearity(pois.prev)
check_zeroinflation(pois.prev)

mejor.pois <- MASS::stepAIC(pois.prev)
summary(mejor.pois)

# Crear Modelos de Hurdle potencialmente adecuados
library(pscl)
mod.H1 <- hurdle(count ~ ., 
                 data = pesca, dist = "poisson", # negbin 
                 zero.dist = "binomial", link = "logit")

summary(mod.H1)

mod.H2 <- hurdle(count ~ child + persons + camper | persons, 
                 data = pesca, dist = "poisson", # negbin 
                 zero.dist = "binomial", link = "logit")
summary(mod.H2)

mod.H3 <-  hurdle(count ~ child + camper | persons, 
                 data = pesca, dist = "poisson", # negbin 
                 zero.dist = "binomial", link = "logit")

mod.H4 <- hurdle(count ~ livebait + child + xb + zg, 
                 data = pesca, dist = "poisson", # negbin 
                 zero.dist = "binomial", link = "logit")

mod.H5 <- hurdle(count ~ livebait + child + xb + zg | camper + persons, 
                 data = pesca, dist = "poisson", # negbin 
                 zero.dist = "binomial", link = "logit")

mod.H6 <- hurdle(count ~ livebait + child + xb + zg | xb + zg,
                 data = pesca, dist = "poisson", # negbin 
                 zero.dist = "binomial", link = "logit")

# Identificación de los modelos con mejor ajuste según AIC
AIC(mejor.pois, mod.H1, mod.H2, mod.H3,
    mod.H4, mod.H5, mod.H6) %>% arrange(AIC)

# Comparandosi los mejores modelos
lmtest::lrtest(mod.H6, mod.H4)
lmtest::lrtest(mod.H6, mod.H1)
lmtest::lrtest(mod.H6, mejor.pois)

# Mejor modelo Interpretación
sjPlot::plot_model(mod.H6, show.values=TRUE,
                   value.offset=0.4)

sjPlot::plot_model(mod.H1, show.values=TRUE,
                   value.offset=0.4)


sjPlot::tab_model(mod.H6)
summary(mod.H6)
```

**Modelo de conteos (poisson):**
Modelamos solamente conteos (números enteros positivos).

Ej: Por cada unidad de aumento de la variable child, se espera que el conteo de peces capturados disminuya por un factor multiplicativo de 0.61 (ó en 39%) 

Ej: El uso de cebo vivo (categoría 1) genera un aumento en el conteo de peces capturados por un factor multiplicativo de 1.92 (ó en 92%), respecto al nivel base (ó respecto a no usar cebo vivo, categoría 0).

**Modelo ZeroInflado (binomial):**
Modelamos cual es el efecto de las variables sobre la Posibilidades de que se tenga conteo.

- Donde 1 = Tener conteo
        0 = No pescar
        
Ej: La posibilidad de EVENTO (Tener conteo) aumenta por un factor multiplicativo de 30.13 con cada unidad de aumento de la variable xb (Densidad de peces carpa).


# **6. Regresión GLMM Logística con Efectos Mixtos**

Problema: Se busca identificar si dos tratamientos (trt) del terreno disminuyen la probabilidad de presencia de bacterias en unas muestras de suelo (y), respecto al control (no tratamiento). Se tomaron 4 mediciones (en 4 tiempos diferentes) para cada unidad muestral, por lo que se sabe que la muestra presenta dependencia (ID). 

```{r}
# Carga la base de datos bacteria de la librería MASS
library(MASS)
data("bacteria")
str(bacteria)

# Generar dos modelos con un intercepto aleatorio
# Aproximación de Laplace
glmm <- glmer(y ~ trt + (1|ID), data = bacteria,
              family = "binomial", nAGQ = 1)

# Cuadratura de Hermit-Gauss 25
glmm1 <- glmer(y ~ trt + (1|ID), data = bacteria,
              family = "binomial", nAGQ = 25)

# Generar un modelo con dos interceptos aleatorios
glmm2 <- glmer(y ~ trt + (1|ID) + (1|week), data = bacteria,
              family = "binomial", nAGQ = 1)

# Comparar ambos modelos
anova(glmm, glmm2)
anova(glmm, glmm1)
anova(glmm2, glmm1)

# Efectos aleatorios en SD respecto a la media general
library(lattice)
dotplot(ranef(glmm))

# Interpretando el mejor modelo
glmm %>% tidy(exponentiate = FALSE, conf.int = TRUE)
tidy(glmm, exponentiate = TRUE, conf.int = TRUE)

# Gráfico de Odds Ratios
library(sjPlot)
library(tidyverse)

plot_model(glmm,  # Modelo
           type = "est", # tipo de gráfico est (estimates)
           show.intercept=TRUE, #mostrar el intercepto
           #digits = 3, #PARA EL NUMERO DE DECIMALES
           #sort.est = TRUE,
           dot.size = 4, # tamaño de punto
           width = 0.2, # ancho de los bigotes
           line.size = 0.7, # ancho de las líneas
           #colors = "black",
           show.values = TRUE, # mostrar valores 
           #value.size = 4,
           vline.color = "gray95", # color línea de no efecto
           value.offset = 0.2) + # mover un poquito el estimado
  theme_test()

# Gráfico de Predicciones: type="pred"
plot_model(glmm, type="eff")

sjPlot::tab_model(glmm)

```

# **7. GLMM de conteos**

# **7.1. Regresión GLMM de Poisson**
Problema: Se evaluó la riqueza de especies en 9 zonas de estudio diferentes (playas, Beach). Se busca identificar si la riqueza de especies es explicada por la exposición de la zona (Exposure), la altura respecto al nivel de marea baja (NAP). Se asume que ambas variables son muy importantes para las especies de la zona.

```{r}
# Carga el excel RIKZ.xlsx
RIKZ <- openxlsx::read.xlsx("slide4/bases/RIKZ.xlsx")
RIKZ <- openxlsx::read.xlsx(file.choose())

str(RIKZ)
RIKZ$Beach <- factor(RIKZ$Beach)
str(RIKZ)

# CREAR LOS MODELOS
# Con Exposure y NAP, e intercepto aleatorio con Beach 
glmm.ko <- glmer(Richness ~ Exposure + NAP + (1|Beach),
                 data = RIKZ, family = poisson(link = "log"))

# Con Exposure e intercepto aleatorio con Beach 
glmm.ko2 <- glmer(Richness ~ Exposure + (1|Beach),
                 data = RIKZ, family = poisson(link = "log"))
  
# Con NAP e intercepto aleatorio con Beach 
glmm.ko3 <- glmer(Richness ~ NAP + (1|Beach),
                 data = RIKZ, family = poisson(link = "log"))
  
# Con NAP, con intercepto y pendientes aleatorias con Beach usando NAP
glmm.ko4 <- glmer(Richness ~ NAP + (NAP|Beach),
                 data = RIKZ, family = poisson(link = "log"))
  
# Con Exposure, con intercepto y pendientes aleatorias con Beach usando Exposure 
glmm.ko5 <- glmer(Richness ~ Exposure + (Exposure|Beach),
                 data = RIKZ, family = poisson(link = "log"))
  
# Con Exposure y NAP, con intercepto y pendientes aleatorias con Beach usando NAP
glmm.ko6 <- glmer(Richness ~ Exposure + NAP + (NAP|Beach),
                 data = RIKZ, family = poisson(link = "log"))
  
# Con Exposure y NAP, con intercepto y pendientes aleatorias con Beach usando Exposure
glmm.ko7 <- glmer(Richness ~ Exposure + NAP + (Exposure|Beach),
                 data = RIKZ, family = poisson(link = "log"))

# Comparar modelos
AIC(glmm.ko, glmm.ko2, glmm.ko3, 
    glmm.ko4, glmm.ko5, glmm.ko6, glmm.ko7) %>% 
  arrange(AIC)

anova(glmm.ko6,glmm.ko)

# Resultados del Mejor Modelo
summary(glmm.ko)

# Verificar si los efectos aleatorios generan realmente variabilidad en las  observaciones (Dotplots o Catterpilar Plots)
dotplot(ranef(glmm.ko))

prueba <- glm(Richness ~ Exposure + NAP,
                 data = RIKZ, 
              family = poisson(link = "log"))

anova(glmm.ko,prueba)

# Resultados con Coeficientes Exponenciados
tidy(glmm.ko, exponentiate=TRUE)

# Chequeo de Sobredispersión
check_overdispersion(glmm.ko)

# Generar gráficos de Predicciones o Efectos
plot_model(glmm.ko, show.values=TRUE)
plot_model(glmm.ko, terms="Exposure", type="eff")
plot_model(glmm.ko, terms="NAP", type="eff")

# install.packages("effects")
plot(effects::allEffects(glmm.ko))

```

# **7.1. Regresión GLMM Binomial Negativa**
Problema: Se pretende identificar si la herbivoría (amd), la disponibilidad de nutrientes (nutrient), la ubicación de la muestra (rack) y el tipo de cultivo inicial (status), afectan la cantidad de frutos producidos por Arabidopsis taliana. Se utilizará como variables de efecto aleatorio a la población (popu) de origen de las plantas, la región, y el grupo genético.

```{r}
# Cargar la base de datos Arabidopsis de la librería lme4
data("Arabidopsis")
View(Arabidopsis)
str(Arabidopsis)

# Transformar a factor las columnas de categorías
Arabidopsis <- Arabidopsis %>% mutate_at(.vars=vars(gen,rack,nutrient),
          .funs=list(factor))
str(Arabidopsis)

# Revisar el rango de la variable Y
# En caso sea muy amplio el rango, logaritmizar.
range(Arabidopsis$total.fruits)
Arabidopsis$y <- log1p(Arabidopsis$total.fruits)
range(Arabidopsis$y)

# Definir los niveles de amd al revés
Arabidopsis$amd <- relevel(Arabidopsis$amd, "unclipped")

# Gráficos exploratorios
library(ggpubr)
ggerrorplot(x="rack", y="y", data=Arabidopsis)
ggerrorplot(x="nutrient", y="y", data=Arabidopsis)
ggerrorplot(x="amd", y="y", data=Arabidopsis)

```

# **Primer paso: hacer un modelo de Poisson**

```{r}
# Hacer un GLMM de Poisson con aproximación de Laplace 
# y popu como efecto aleatorio
aramod <- glmer(total.fruits ~ amd + nutrient + rack +gen + (1|popu),
                data=Arabidopsis, family="poisson", nAGQ=1) 

# Revisar sobredispersión
library(performance)
check_overdispersion(aramod)
```

# **Realizar la regresión Binomial Negativa GLM y GLMM**

```{r}
# Crear el modelo GLM Binomial Negativa
GLM <- glm.nb(y ~ rack + nutrient + amd + status,
                 data= Arabidopsis)

# Crear los modelos GLMM Binomial Negativa
mod1 <- glmer.nb(y ~ rack + nutrient + amd + status + (1|popu),
                 data= Arabidopsis, nAGQ=1)

mod2 <- glmer.nb(y ~ rack + nutrient + amd + status + (1|reg/popu),
                 data= Arabidopsis, nAGQ=1)

mod3 <- glmer.nb(y ~ rack + nutrient + amd + status + (1|popu/gen),
                 data= Arabidopsis, nAGQ=1)

mod4 <- glmer.nb(y ~ rack + nutrient + amd + status + (1|reg/popu/gen),
                 data= Arabidopsis, nAGQ=1)

# Revisar el ajuste según AIC
library(tidyverse)
AIC(mod1, mod2, mod3, mod4, GLM) %>% arrange(AIC)

# Comparar los mejores modelos
# y seleccionar el mejor
anova(mod1, mod2)
anova(mod1, mod3)

# Revisar los efectos aleatorios para popu
library(lattice)
dotplot(ranef(mod1))

# Interpretando el mejor modelo
library(sjPlot)
tab_model(mod1)

plot_model(mod1, type="est", show.values=TRUE)

plot(effects::allEffects(mod1))

# El que estuviera en el rack 2 reduce la cantidad
# de frutos (CDF).
# La aplicación de nutrientes aumenta la CDF.
# La herbivoría inducida reduce la cantidad
# Tanto cultivar en Placa petri como en transplante,
# aunque indistinguibles, afectan negativamente
# a la producción de frutos
```

